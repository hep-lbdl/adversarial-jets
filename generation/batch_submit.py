#!/usr/bin/env python

'''
batch_submit.py -- a script to submit batched 
jet-image event generation jobs.

Author: Luke de Oliveira
'''

import argparse
import sys
import os
import datetime
from subprocess import Popen, PIPE, STDOUT
import logging

LOGGER_PREFIX = ' %s'
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


def log(msg):
    logger.info(LOGGER_PREFIX % msg)

####### CHANGE THESE PARAMETERS ###########

BOSON_MASS = 800

PT_HAT_MIN, PT_HAT_MAX = [200, 400]

###########################################


def simulation_dir():
    """
    assumes you can type `python batch_submit.py`
    """
    return os.getcwd()


def generate_script(d):
    '''
    Generates a boilerplate script of the form:

    cd /path/to/jet-simulations
    source ./setup.sh
    ./event-gen/event-gen --OutFile test.root --Proc 3 --NEvents 100 --pThatMin 200 --pThatMax 400 --BosonMass 800

    where the flags are filled in by `d`

    `d` should have the following keys:
        * file
        * process
        * events
        * pthatmin
        * pthatmax
        * bosonmass

    '''
    return 'cd {}\n'.format(simulation_dir()) + 'source ./setup.sh\n./event-gen/bin/jet-image-maker --OutFile {file} \
    --Proc {process} --NEvents {events} --pThatMin {pthatmin} --pThatMax {pthatmax} --BosonMass {bosonmass}'.format(**d)


def invoke_bsub(name, queue, log):
    '''
    Starts up bsub, and hangs in a state where a script can be piped in.
    '''
    return 'bsub -J "%s" -o %s -q %s' % (
        name, log, queue
    )


if __name__ == '__main__':

    parser = argparse.ArgumentParser()
    parser.add_argument('--jobs', type=int,
                        help='Number of jobs to run', required=True)

    parser.add_argument('--events', type=int,
                        help='Number of events', required=True)

    parser.add_argument('--output-dir', type=str, default='./files',
                        help='path to directory where data files should be written')

    parser.add_argument('--file-prefix', type=str, default='GENERATED',
                        help='prefix written to the start of all output files.')

    parser.add_argument('--log-dir', type=str, default='./logs',
                        help='Path to directory to write the logs')

    parser.add_argument('--process', type=str, default='qcd',
                        help='which process?', choices=['qcd', 'wprime'])

    process_dict = {'qcd': 4, 'wprime': 2}

    args = parser.parse_args()

    log('Determining output directories.')

    # -- get the simulation directory
    work_dir = simulation_dir()

    # -- create a timestamped subdir
    subdir = datetime.datetime.now().strftime('%b%d-%H%M%S')

    # -- make the logging directory
    if not os.path.exists(os.path.join(args.log_dir, subdir)):
        os.makedirs(os.path.join(args.log_dir, subdir))

    log('Will write logs to {}'.format(os.path.join(args.log_dir, subdir)))

    # -- make the job output directory
    scratch_space = os.path.join(args.output_dir, subdir)
    if not os.path.exists(os.path.join(args.output_dir, subdir)):
        os.makedirs(scratch_space)

    log('Will write samples to {}'.format(scratch_space))

    log('Script submitted for {} generation.'.format(args.process))

    log('Generating {} x {} = {} events.'.format(
        args.jobs, args.events, args.jobs * args.events
    )
    )
    # -- which process?
    process_code = process_dict[args.process]

    for job in xrange(args.jobs):
        log('Launching job %s of %s...' % (job + 1, args.jobs))

        # -- dump the bsub output into a nice format
        log_file = os.path.join(args.log_dir, subdir,
                                'log_job_{}.log'.format(job))

        # -- format the output files with all the relevant kinematic shit
        output_file = '%s_process_%s_bosonmass%s_pthat%s-%s_nevents%s_job%s.root' % (
            args.file_prefix,
            args.process,
            BOSON_MASS,
            PT_HAT_MIN,
            PT_HAT_MAX,
            args.events,
            job
        )

        # -- this formats the autogenerated script
        job_params = {
            'file': os.path.join(scratch_space, output_file),
            'process': process_code,
            'events': args.events,
            'pthatmin': PT_HAT_MIN,
            'pthatmax': PT_HAT_MAX,
            'bosonmass': BOSON_MASS
        }

        # -- catalogue where shit is going
        log('Job log is {}.'.format(log_file))
        log('Job output is {}.'.format(os.path.join(scratch_space, output_file)))

        # -- wrap the call to the batch system
        cmd = invoke_bsub('j%sof%s' % (job + 1, args.jobs), 'medium', log_file)

        log('Call is: {}'.format(cmd))

        # -- Open a process...
        job_out = Popen(cmd.split(), stdin=PIPE, stdout=PIPE, stderr=STDOUT)

        # -- ...and feed it the autogen script.
        _ = job_out.communicate(input=generate_script(job_params))
        log('Success.')
